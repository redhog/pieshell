{
  "name": "Pieshell",
  "tagline": "Python shell environment that combines the expressiveness of shell pipelines with the prower of python iterators",
  "body": "# About\r\n\r\nPieshell is a Python shell environment that combines the\r\nexpressiveness of shell pipelines with the prower of python iterators.\r\n\r\nIt can be used in two major ways:\r\n\r\n* As an interactive shell replacing e.g. bash\r\n* As an ordinary python module replacing e.g. subprocess.Popen\r\n\r\n# Table of contents\r\n\r\n* [As a shell](#as-a-shell)\r\n  * [Executing basic commands](#executing-basic-commands)\r\n  * [Full syntsax for command lines](#full-syntsax-for-command-lines)\r\n  * [Redirects](#redirects)\r\n  * [Interfacing between python functions and shell commands](#interfacing-between-python-functions-and-shell-commands)\r\n  * [Environment variables](#environment-variables)\r\n  * [Argument expansion](#argument-expansion)\r\n* [As a python module](#as-a-python-module)\r\n  * [Environment variables](#environment-variables-1)\r\n  * [Argument expansion](#argument-expansion-1)\r\n  * [Pysh modules](#pysh-modules)\r\n* [Configuration](#configuration)\r\n* [Copyright](#copyright)\r\n\r\n\r\n# As a shell\r\n\r\n## Executing basic commands\r\n\r\nTo start pieshell in interactive mode, just run the command pieshell:\r\n\r\n    $ pieshell\r\n\r\nThe interactive pieshell environment supports all normal python syntax.\r\n\r\n    140:/home/redhog/Projects/beta/pieshell >>> print 3+4\r\n    7\r\n\r\nIn addition, you can run programs just like in any shell by writing their names\r\n\r\n    140:/home/redhog/Projects/beta/pieshell >>> ls\r\n    build  deps  dist  LICENSE.txt\tpieshell  pieshell.egg-info  README.md\tsetup.py\r\n\r\nParameters to programs however have to be given as proper python strings\r\nwithin parenthesis, like a python function call\r\n\r\n    140:/home/redhog/Projects/beta/pieshell >>> ls(\"-a\")\r\n    .  ..  build  deps  dist  .git\t.gitignore  LICENSE.txt  pieshell  pieshell.egg-info  .#README.md  README.md  setup.py\r\n\r\nPiping the standard output of one command to the standard input of\r\nanother works just like in bash\r\n\r\n    140:/home/redhog/Projects/beta/pieshell >>> ls(\"-a\") | grep(\"-e\", \".py\")\r\n    setup.py\r\n\r\nChanging directory is done using the command cd:\r\n\r\n    140:/home/redhog/Projects/beta/pieshell >>> cd(\"..\")\r\n    140:/home/redhog/Projects/beta >>> \r\n\r\n## Full syntsax for command lines\r\n\r\nTo execute commands that require a path, for example ones in the current directory, or commands with a dot in their names\r\n\r\n    140:/home/redhog/Projects/beta/pieshell >>> _(\"./setup.py\", \"--help\")\r\n    Common commands: (see '--help-commands' for more)\r\n    ...\r\n\r\nThe underscore represents the virtual root command that has no parameters, not even a command name. In general, there are two equivalent syntaxes for parameters: as function parameter strings, and as attribute names. The two syntaxes can be mixed freely. All of the following are equivalent:\r\n\r\n    _(\"foo\", \"bar\", \"fie\")\r\n    _.foo(\"bar\", \"fie\")\r\n    _.foo.bar.fie()\r\n    foo.bar.fie()\r\n    foo.bar.fie\r\n\r\nExample usage:\r\n\r\n    git.diff(\"-U\")\r\n\r\nIn addition to these two generic syntaxes, the function call syntax also supports named parameters, which are converted into \"--name=value\" pairs. Note that the order can not be guaranteed as named parameters are sent around as dictionaries inside python:\r\n\r\n    git.diff(unified=4)\r\n\r\n## Redirects\r\n\r\nStandard out and standard in of a pipeline can be redirected to a file\r\nby piping to or from a string (the filename). As a special case, None\r\nis a short hand for \"/dev/null\"\r\n\r\n    140:/home/redhog/Projects/beta/pieshell >>> ls | \"foo\"\r\n\r\n    140:/home/redhog/Projects/beta/pieshell >>> \"foo\" | cat\r\n    bar\r\n    build\r\n    deps\r\n    dist\r\n    foo\r\n    LICENSE.txt\r\n    pieshell\r\n    pieshell.egg-info\r\n    README.md\r\n    setup.py\r\n\r\n    140:/home/redhog/Projects/beta/pieshell >>> ls | None\r\n\r\nRedirects can also be made with a more explicit syntax that allows\r\nredirecting other file descriptors than stdin and stdout:\r\n\r\n    139:/home/redhog/Projects/beta/pieshell >>> cat | Redirect(\"stdin\", \"foo\") | Redirect(\"stdout\", \"bar\")\r\n\r\nThe constructor for redirect takes the following arguments:\r\n\r\n    Redirect(fd, source, flag=None, mode=0777)\r\n\r\nfd can be either an int, or one of \"stdin\", \"stdout\" and \"stderr.\r\nsource is either a string filename, or an int file descriptor. flag\r\nand mode have the same semantics as for os.open(). Flags do not have\r\nto be given for stdin, stdout and stderr / fd 0, 1 and 2 and defaults\r\nto os.O_RDONLY or os.O_RDONLY | os.O_CREAT.\r\n\r\n## Interfacing between python functions and shell commands\r\n\r\nShell commands are first class python objects, and their input and\r\noutput can be interacted with easily from python in the form of\r\niterators. Iterating over a shell command iterates over the lines of\r\nits standard out\r\n\r\n    140:/home/redhog/Projects/beta/pieshell >>> list(ls(\"-a\"))\r\n    ['.', '..', 'build', 'deps', 'dist', '.git', '.gitignore', 'LICENSE.txt', 'pieshell', 'pieshell.egg-info', '.#README.md', 'README.md', 'setup.py']\r\n    140:/home/redhog/Projects/beta/pieshell >>> for x in ls(\"-a\"):\r\n    ...   if x.endswith('.py'):\r\n    ...      print x\r\n    ... \r\n    setup.py\r\n\r\nPiping an iterator into a shell command, sends its items as lines to\r\nthe standard in of the shell command\r\n\r\n    140:/home/redhog/Projects/beta/pieshell >>> list([\"foo\", \"bar.py\", \"fie.py\"] | grep(\"-e\", \".py\"))\r\n    ['bar.py', 'fie.py']\r\n    140:/home/redhog/Projects/beta/pieshell >>> def foo():\r\n    ...     yield \"hello\"\r\n    ...     yield \"world\"\r\n    140:/home/redhog/Projects/beta/pieshell >>> foo() | cat\r\n    hello\r\n    world\r\n\r\nIn addtion, iterators and pipelines may be used as arguments to\r\ncommands and will be seen by the command as a filename, which when\r\nopened and read from will produce the output of that iterator as\r\nlines, or the standard output of the pipeline.\r\n\r\n    140:/home/redhog/Projects/beta/pieshell >>> list(cat([\"foo\", \"bar\"]))\r\n    ['foo', 'bar']\r\n    140:/home/redhog/Projects/beta/pieshell >>> list(cat([\"foo\", \"bar\"] | cat))\r\n    ['foo', 'bar']\r\n\r\n## Environment variables\r\n\r\nEnvironment variables are available directly in the shell as\r\nvariables, together with any local python variables. In addition, they\r\nare available in the dictionary exports.\r\n\r\n    140:/home/redhog/Projects/beta/pieshell >>> LANG\r\n    'en_US.UTF-8'\r\n\r\nAssigning to the name of an already exported environment variable\r\nupdates the value of that variable.\r\n\r\n    140:/home/redhog/Projects/beta/pieshell >>> LANG = \"sv_SE.UTF-8\"\r\n    140:/home/redhog/Projects/beta/pieshell >>> exports[\"LANG\"]\r\n    'sv_SE.UTF-8'\r\n\r\nAssigning to a variable name not already used as an environment\r\nvariable creates a local python variable.\r\n\r\n    140:/home/redhog/Projects/beta/pieshell >>> foo = \"hello\"\r\n    140:/home/redhog/Projects/beta/pieshell >>> \"foo\" in exports\r\n    False\r\n    140:/home/redhog/Projects/beta/pieshell >>> foo\r\n    'hello'\r\n\r\nTo export a new variable, you have to assign it in the exports\r\ndictionary.\r\n\r\n    140:/home/redhog/Projects/beta/pieshell >>> exports[\"bar\"] = \"world\"\r\n    140:/home/redhog/Projects/beta/pieshell >>> bar\r\n    'world'\r\n\r\n## Argument expansion\r\n\r\nAll parameter strings in commands are subject to expansion unless\r\nwrapped in a call to R(), e.g. R(\"my * string * here\")ñ.\r\n\r\n  * \"~\" and \"~username\" are expanded using os.path.expanduser()\r\n\r\n  * Variable expansion is done using the python % operator on python\r\n    variables as well as environment variables.\r\n\r\n  * Pattern matching is done using glob.glob()\r\n\r\n# As a python module\r\n\r\n    >>> from pieshell import *\r\n\r\nAll functionality available in the interactive shell is available when\r\nusing pieshell as an ordinary python module. However, a slighly more\r\ncumbersome syntax is required.\r\n\r\nIn particular, shell commands can not be run just by writing their\r\nnames. Instead, they have to be accessed as members of the \"env\"\r\nobject:\r\n\r\n    >>> list(env.ls(\"-a\") | env.grep(\"-e\", \"io\"))\r\n    [\"iterio.py\", \"iterio.pyc\"]\r\n\r\nCommands are also not run with standard out to the screen when simply\r\nprinted using the repr() function but must instead be used as\r\niterators as is done above using the list() function.\r\n\r\nThe env object holds the current working directory, which can be changed with\r\n\r\n    >>> env.cd(\"..\")    \r\n\r\nYou can also create multiple environments and use them\r\nsiumultaneously, even within the same pipeline\r\n\r\n    >>> env2 = env()\r\n    >>> env2.cd(\"somedir\")\r\n\r\n## Environment variables\r\n\r\nEnvironment variables are available as a dictionary in env._exports.\r\n\r\n## Argument expansion\r\n\r\nVariable expansion is only done on environment variables, as there is\r\nno way for pieshell to find out about the right scope to do variable\r\nlookups in in any given situation.\r\n\r\n## Pysh modules\r\n\r\nIn addition to being able to use pieshell code in ordinary python\r\nmodules using this slightly more verbose syntax, pieshell supports\r\nimporting modules named modulename.pysh rather than modulename.py.\r\nPysh modules support the full syntax of the interactive pieshell\r\nconsole. Pysh modules can be imported using the standard import syntax\r\nas soon as pieshell itself has been imported, and from the interactive\r\npieshell.\r\n\r\n# Configuration\r\n\r\nWhen running pieshell in interactive mode it executes\r\n~/.config/pieshell at startup if it exists. This file can be used to\r\nconfigure the interactive environment the same way ~/.bashrc can be\r\nused to configure the bash shell. For example it can be used to load\r\npython modules, execute shell pipelines or set environment variables.\r\nAn example config file is supplied in contrib/cofig.\r\n\r\n# Builtins\r\n\r\nWhile pieshell lets you pipe to and from ordinary python functions,\r\nthey don't offer the same syntax and tab-completion as external\r\ncommands (e.g. 'myfunction.arg1.arg2(name=value)'), they can't modify\r\nthe environment or do fancy redirects. Builtin commands provide all of\r\nthis, at the cost of a slightly clumsier syntax:\r\n\r\n    class MyMagicBuiltin(pieshell.Builtin):\r\n        \"\"\"More magic to the people\r\n        \"\"\"\r\n        name = \"magic\"\r\n\r\n        def _run(self, redirects, sess, indentation = \"\"):\r\n            # redirects is an instance of pieshell.Redirects\r\n            #\r\n            # sess is an opaque data structure that must be passed to\r\n            # any call to _run() you do yourself from this method (or\r\n            # any function it calls).\r\n            #\r\n            # indentation is a string containing only whitespace, to\r\n            # be prepended to any debug printing lines you print.\r\n            #\r\n            # Returns a list of instances of some pieshell.RunningItem\r\n            # subclass\r\n\r\n            self._cmd = self._env.find(\r\n                \".\", \"-name\", \"%s.txt\" % self._arg[1]) | self._env.tac\r\n            return self._cmd._run(redirects, sess, indentation)\r\n\r\n\r\n        # Optional for tab completion\r\n        def __dir__(self):\r\n            return [\"light\", \"dark\"]\r\n    pipeline.BuiltinRegistry.register(CdBuiltin)\r\n\r\n\r\n# Copyright\r\n\r\nPieshell copyright 2016 Egil Möller <egil.moller@piratpartiet.se>\r\n\r\nPieshell is free software: you can redistribute it and/or modify it\r\nunder the terms of the GNU Lesser General Public License as published\r\nby the Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nThis program is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU Lesser General Public\r\nLicense along with this program. If not, see\r\n<http://www.gnu.org/licenses/>.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}